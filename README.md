# java-lotto-precourse

https://apply.techcourse.co.kr/assignment/14/mission/49

**구현할 기능 목록은 문서 하단(요구사항 아래)에 작성되어 있습니다.**

## **목표**

### **학습 목표**

- [ ]  관련 함수를 묶어 클래스를 만들고, 객체들이 협력하여 하나의 큰 기능을 수행하도록 한다.
- [ ]  클래스와 함수에 대한 단위 테스트를 통해 의도한 대로 정확하게 작동하는 영역을 확보한다.
- [ ]  [2주 차 공통 피드백](https://docs.google.com/document/d/1QW_762N0WC6JvAiDHNBYXzLJ60y1Azex1d7tID0BggM/edit?usp=sharing)을 최대한 반영한다.

---

## **프리코스 진행 방식**

### **진행 방식**

- [ ]  미션은 **과제 진행 요구 사항**, **기능 요구 사항**, **프로그래밍 요구 사항** 세 가지로 구성되어 있다.
- [ ]  세 개의 요구 사항을 만족하기 위해 노력한다. 특히 기능을 구현하기 전에 기능 목록을 만들고, 기능 단위로 커밋 하는 방식으로 진행한다.
- [ ]  **기능 요구 사항에 기재되지 않은 내용은 스스로 판단하여 구현한다.**
- [ ]  매주 진행할 미션은 화요일 오후 3시부터 확인할 수 있으며, 다음 주 월요일까지 구현을 완료하여 제출해야 한다. **제출은 일요일 오후 3시부터 가능하다.**
- [ ]  **정해진 시간을 지키지 않을 경우 미션을 제출하지 않은 것으로 간주한다.**
- [ ]  종료 일시 이후에는 추가 푸시를 허용하지 않는다.

### **미션 제출 방법**

- [ ]  미션 구현을 완료한 후 GitHub을 통해 제출해야 한다.
    - GitHub을 활용한 제출 방법은 [프리코스 과제 제출](https://github.com/woowacourse/woowacourse-docs/tree/master/precourse) 문서를 참고해 제출한다.
- [ ]  GitHub에 미션을 제출한 후 [우아한테크코스 지원 플랫폼](https://apply.techcourse.co.kr/)에 PR 링크를 포함하여 최종 제출한다.
    - 자세한 안내는 [제출 가이드](https://github.com/woowacourse/woowacourse-docs/tree/master/precourse#%EC%A0%9C%EC%B6%9C-%EA%B0%80%EC%9D%B4%EB%93%9C)를 참고한다.
    - 과제를 수행하면서 느낀 점, 배운 점, 많은 시간을 투자한 부분 등 자유롭게 작성한다.

### **과제 제출 전 체크 리스트**

- [ ]  기능을 올바르게 구현했더라도 **요구 사항에 명시된 출력 형식을 따르지 않으면 0점**을 받게 된다.
- [ ]  기능 구현을 완료한 후 아래 가이드에 따라 모든 테스트가 성공적으로 실행되는지 확인한다.
- [ ]  **테스트가 실패하면 점수가 0점**이 되므로 제출하기 전에 반드시 확인한다.

### **테스트 실행 가이드**

- [ ]  터미널에서 `java -version`을 실행하여 Java 버전이 21인지 확인한다. Eclipse 또는 IntelliJ IDEA와 같은 IDE에서 Java 21로 실행되는지 확인한다.
- [ ]  터미널에서 Mac 또는 Linux 사용자의 경우 `./gradlew clean test` 명령을 실행하고, Windows 사용자의 경우 `gradlew.bat clean test` 또는 `.\gradlew.bat clean test` 명령을 실행할 때 모든 테스트가 아래와 같이 통과하는지 확인한다.

```
BUILD SUCCESSFUL in 0s
```

---

# **로또**

## **과제 진행 요구 사항**

- [ ]  미션은 [로또](https://github.com/woowacourse-precourse/java-lotto-7) 저장소를 포크하고 클론하는 것으로 시작한다.
- [ ]  **기능을 구현하기 전 `README.md`에 구현할 기능 목록을 정리**해 추가한다.
- [ ]  Git의 커밋 단위는 앞 단계에서 `README.md`에 정리한 기능 목록 단위로 추가한다.
    - [AngularJS Git Commit Message Conventions](https://gist.github.com/stephenparish/9941e89d80e2bc58a153)을 참고해 커밋 메시지를 작성한다.
- [ ]  자세한 과제 진행 방법은 프리코스 진행 가이드 문서를 참고한다.

## **기능 요구 사항**

간단한 로또 발매기를 구현한다.

- [ ]  로또 번호의 숫자 범위는 1~45까지이다.
- [ ]  1개의 로또를 발행할 때 중복되지 않는 6개의 숫자를 뽑는다.
- [ ]  당첨 번호 추첨 시 중복되지 않는 숫자 6개와 보너스 번호 1개를 뽑는다.
- [ ]  당첨은 1등부터 5등까지 있다. 당첨 기준과 금액은 아래와 같다.
    - 1등: 6개 번호 일치 / 2,000,000,000원
    - 2등: 5개 번호 + 보너스 번호 일치 / 30,000,000원
    - 3등: 5개 번호 일치 / 1,500,000원
    - 4등: 4개 번호 일치 / 50,000원
    - 5등: 3개 번호 일치 / 5,000원
- [ ]  로또 구입 금액을 입력하면 구입 금액에 해당하는 만큼 로또를 발행해야 한다.
- [ ]  로또 1장의 가격은 1,000원이다.
- [ ]  당첨 번호와 보너스 번호를 입력받는다.
- [ ]  사용자가 구매한 로또 번호와 당첨 번호를 비교하여 당첨 내역 및 수익률을 출력하고 로또 게임을 종료한다.
- [ ]  사용자가 잘못된 값을 입력할 경우 `IllegalArgumentException`을 발생시키고, "[ERROR]"로 시작하는 에러 메시지를 출력 후 그 부분부터 입력을 다시 받는다.
    - `Exception`이 아닌 `IllegalArgumentException`, `IllegalStateException` 등과 같은 명확한 유형을 처리한다.

### **입출력 요구 사항**

### **입력**

- [ ]  로또 구입 금액을 입력 받는다. 구입 금액은 1,000원 단위로 입력 받으며 1,000원으로 나누어 떨어지지 않는 경우 예외 처리한다.

```
14000

```

- [ ]  당첨 번호를 입력 받는다. 번호는 쉼표(,)를 기준으로 구분한다.

```
1,2,3,4,5,6

```

- [ ]  보너스 번호를 입력 받는다.

```
7

```

### **출력**

- [ ]  발행한 로또 수량 및 번호를 출력한다. 로또 번호는 오름차순으로 정렬하여 보여준다.

```prolog
8개를 구매했습니다.
[8, 21, 23, 41, 42, 43]
[3, 5, 11, 16, 32, 38]
[7, 11, 16, 35, 36, 44]
[1, 8, 11, 31, 41, 42]
[13, 14, 16, 38, 42, 45]
[7, 11, 30, 40, 42, 43]
[2, 13, 22, 32, 38, 45]
[1, 3, 5, 14, 22, 45]

```

- [ ]  당첨 내역을 출력한다.

```
3개 일치 (5,000원) - 1개
4개 일치 (50,000원) - 0개
5개 일치 (1,500,000원) - 0개
5개 일치, 보너스 볼 일치 (30,000,000원) - 0개
6개 일치 (2,000,000,000원) - 0개

```

- [ ]  수익률은 소수점 둘째 자리에서 반올림한다. (ex. 100.0%, 51.5%, 1,000,000.0%)

```erlang
총 수익률은 62.5%입니다.

```

- [ ]  예외 상황 시 에러 문구를 출력해야 한다. 단, 에러 문구는 "[ERROR]"로 시작해야 한다.

```prolog
[ERROR] 로또 번호는 1부터 45 사이의 숫자여야 합니다.

```

### **실행 결과 예시**

```prolog
구입금액을 입력해 주세요.
8000

8개를 구매했습니다.
[8, 21, 23, 41, 42, 43]
[3, 5, 11, 16, 32, 38]
[7, 11, 16, 35, 36, 44]
[1, 8, 11, 31, 41, 42]
[13, 14, 16, 38, 42, 45]
[7, 11, 30, 40, 42, 43]
[2, 13, 22, 32, 38, 45]
[1, 3, 5, 14, 22, 45]

당첨 번호를 입력해 주세요.
1,2,3,4,5,6

보너스 번호를 입력해 주세요.
7

당첨 통계
---
3개 일치 (5,000원) - 1개
4개 일치 (50,000원) - 0개
5개 일치 (1,500,000원) - 0개
5개 일치, 보너스 볼 일치 (30,000,000원) - 0개
6개 일치 (2,000,000,000원) - 0개
총 수익률은 62.5%입니다.

```

## **프로그래밍 요구 사항 1**

- [ ]  JDK 21 버전에서 실행 가능해야 한다.
- [ ]  프로그램 실행의 시작점은 `Application`의 `main()`이다.
- [ ]  `build.gradle` 파일은 변경할 수 없으며, **제공된 라이브러리 이외의 외부 라이브러리는 사용하지 않는다.**
- [ ]  프로그램 종료 시 `System.exit()`를 호출하지 않는다.
- [ ]  프로그래밍 요구 사항에서 달리 명시하지 않는 한 파일, 패키지 등의 이름을 바꾸거나 이동하지 않는다.
- [ ]  자바 코드 컨벤션을 지키면서 프로그래밍한다.
    - 기본적으로 [Java Style Guide](https://github.com/woowacourse/woowacourse-docs/blob/main/styleguide/java)를 원칙으로 한다.

## **프로그래밍 요구 사항 2**

- [ ]  indent(인덴트, 들여쓰기) depth를 3이 넘지 않도록 구현한다. 2까지만 허용한다.
    - 예를 들어 while문 안에 if문이 있으면 들여쓰기는 2이다.
    - 힌트: indent(인덴트, 들여쓰기) depth를 줄이는 좋은 방법은 함수(또는 메서드)를 분리하면 된다.
- [ ]  3항 연산자를 쓰지 않는다.
- [ ]  함수(또는 메서드)가 한 가지 일만 하도록 최대한 작게 만들어라.
- [ ]  JUnit 5와 AssertJ를 이용하여 정리한 기능 목록이 정상적으로 작동하는지 테스트 코드로 확인한다.
    - 테스트 도구 사용법이 익숙하지 않다면 아래 문서를 참고하여 학습한 후 테스트를 구현한다.
        - [JUnit 5 User Guide](https://junit.org/junit5/docs/current/user-guide)
        - [AssertJ User Guide](https://assertj.github.io/doc)
        - [AssertJ Exception Assertions](https://www.baeldung.com/assertj-exception-assertion)
        - [Guide to JUnit 5 Parameterized Tests](https://www.baeldung.com/parameterized-tests-junit-5)

## **프로그래밍 요구 사항 3**

- [ ]  함수(또는 메서드)의 길이가 15라인을 넘어가지 않도록 구현한다.
    - 함수(또는 메서드)가 한 가지 일만 잘 하도록 구현한다.
- [ ]  else 예약어를 쓰지 않는다.
    - else를 쓰지 말라고 하니 switch/case로 구현하는 경우가 있는데 switch/case도 허용하지 않는다.
    - 힌트: if 조건절에서 값을 return하는 방식으로 구현하면 else를 사용하지 않아도 된다.
- [ ]  Java Enum을 적용하여 프로그램을 구현한다.
- [ ]  구현한 기능에 대한 단위 테스트를 작성한다. 단, UI(System.out, System.in, Scanner) 로직은 제외한다.
    - 단위 테스트 작성이 익숙하지 않다면 `LottoTest`를 참고하여 학습한 후 테스트를 작성한다.

### **라이브러리**

- [ ]  `camp.nextstep.edu.missionutils`에서 제공하는 `Randoms` 및 `Console` API를 사용하여 구현해야 한다.
    - Random 값 추출은 `camp.nextstep.edu.missionutils.Randoms`의 `pickUniqueNumbersInRange()`를 활용한다.
    - 사용자가 입력하는 값은 `camp.nextstep.edu.missionutils.Console`의 `readLine()`을 활용한다.

### **사용 예시**

- 1에서 45 사이의 중복되지 않은 정수 6개 반환

```java
Randoms.pickUniqueNumbersInRange(1, 45, 6);

```

### **Lotto 클래스**

- [ ]  제공된 `Lotto` 클래스를 사용하여 구현해야 한다.
- [ ]  `Lotto`에 `numbers` 이외의 필드(인스턴스 변수)를 추가할 수 없다.
- [ ]  `numbers`의 접근 제어자인 `private`은 변경할 수 없다.
- [ ]  `Lotto`의 패키지를 변경할 수 있다.

```java
public class Lotto {
    private final List<Integer> numbers;

    public Lotto(List<Integer> numbers) {
        validate(numbers);
        this.numbers = numbers;
    }

    private void validate(List<Integer> numbers) {
        if (numbers.size() != 6) {
            throw new IllegalArgumentException("[ERROR] 로또 번호는 6개여야 합니다.");
        }
    }

    // TODO: 추가 기능 구현
}
```

---

**입출력** `feature/view`

입력

- [x]  로또 구입 금액 입력
- [ ]  당첨 번호 입력
   - [ ]  쉼표(,)를 기준으로 구분
- [ ]  보너스 번호 입력

출력

- [x]  발행한 로또 수량 출력
- [x]  발행한 로또 번호 출력
   - [x]  로또 번호를 오름차순으로 정렬
- [ ]  당첨 내역 출력
- [ ]  수익률 출력
   - [ ]  수익률은 소수점 둘째 자리에서 반올림(.0까지 출력)
- [ ]  예외 상황 시 에러 문구 출력
   - [ ]  에러 문구 “[ERROR]”로 시작

**로또 서비스** `feature/service`

- [x]  로또 발행
   - [x]  로또 번호의 숫자 범위는 1~45
   - [x]  같은 번호가 중복되지 않는 6개의 숫자
- [ ]  당첨 번호 추첨
- [ ]  당첨 내역 저장
   - 1등: 6개 번호 일치 / 2,000,000,000원
   - 2등: 5개 번호 + 보너스 번호 일치 / 30,000,000원
   - 3등: 5개 번호 일치 / 1,500,000원
   - 4등: 4개 번호 일치 / 50,000원
   - 5등: 3개 번호 일치 / 5,000원
- [ ]  수익률 계산

**테스트**

- [x]  로또 구입 금액 입력 테스트
- [ ]  당첨 번호 입력 테스트
- [ ]  보너스 번호 입력 테스트
- [ ]  로또 발행 테스트
- [ ]  당첨 번호 추첨 테스트
- [ ]  당첨 내역 저장 테스트
- [ ]  수익률 계산 테스트
- [ ]  발행한 로또 수량 출력 테스트
- [ ]  발행한 로또 번호 출력 테스트
- [ ]  당첨 내역 출력 테스트
- [ ]  수익률 출력 테스트
- [ ]  에러 문구 테스트

**예외처리**

- [x]  구입 금액이 숫자가 아니면 예외처리
- [x]  구입 금액이 1000원 단위가 아니면 예외처리
- [x]  구입 금액이 0 이하면 예외처리

---

# 2주차 공통 피드백 체크리스트

- [ ]  README.md를 상세히 작성한다

  미션 저장소의 README.md는 소스 코드 이전에 프로젝트의 개요를 소개하는 문서다. 이 문서를 통해 해당 프로젝트가 어떤 프로젝트인지, 주요 기능이 무엇인지 소개할 수 있다. 효과적으로 작성하기 위해 마크다운 문법을 검색하여 학습하고, 이를 활용해 README.md를 작성해 본다.

- [ ]  기능 목록을 재검토한다

  기능 목록을 작성할 때 클래스 설계와 구현, 메서드 설계와 구현 같은 상세한 내용은 포함하지 않는다. 클래스 이름이나 메서드 시그니처, 반환값 등은 언제든지 변경될 수 있기 때문이다. 구현해야 할 기능 목록을 중심으로 작성하되, **정상적인 경우뿐만 아니라 예외 상황도 함께 정리**한다. 예외 상황은 시작 단계에서 파악하기 어려우므로, 기능을 구현하면서 지속적으로 업데이트하는 것이 좋다.

- [ ]  기능 목록을 업데이트한다

  README.md 파일의 기능 목록은 구현 과정에서 변경될 수 있다. 시작부터 모든 기능을 완벽하게 정리해야 한다는 부담을 갖기보다는, 기능을 구현하면서 문서를 지속적으로 업데이트하는 것을 목표로 한다. 이를 통해 죽은 문서가 아닌 살아있는 문서로 유지될 수 있도록 노력해 보자.

- [ ]  값을 하드 코딩하지 않는다

  코드 내에서 문자열이나 숫자 값을 하드 코딩하지 않는다. 대신 상수(static final)를 정의하고 의미 있는 이름을 부여하여 해당 값이 어떤 역할을 하는지 명확히 드러낸다. 구글에 “java 상수”등의 키워드로 검색하여 상수 구현 방법을 학습하고 코드에 적용해 본다.

- [ ]  구현 순서도 코딩 컨벤션이다

  클래스는 **상수, 멤버 변수, 생성자, 메서드** 순으로 작성한다.

   ```java
   class A {
       상수(static final) 또는 클래스 변수
       인스턴스 변수
       생성자
       메서드
   }
   ```
   
  ---

- [ ]  변수 이름에 자료형은 사용하지 않는다

  변수 이름에 자료형, 자료 구조 등을 포함하지 않는다. 변수 이름은 의미를 명확히 드러낼 수 있도록 하고, 자료형은 코드 작성 시점에 자연스럽게 이해될 수 있도록 한다.

   ```java
   String carNameList = Console.readLine();
   String[] arrayString = carNameList.split(",");
   ```
   
  ---

- [ ]  한 메서드가 한 가지 기능만 담당하게 한다

  함수의 길이가 길어진다면 여러 기능을 한 함수에서 처리하려는 신호일 가능성이 높다. 예를 들어, 안내 문구 출력, 사용자 입력 처리, 유효값 검증 등의 작업을 한 함수에 모두 포함하는 대신, 이를 각기 다른 함수로 분리해 본다.

   ```java
   public List<String> userInput() {
       System.out.println("경주할 자동차 이름을 입력하세요(이름은 쉼표(,)를 기준으로 구분).");
       String userInput = Console.readLine().trim();
       String[] splittedName = userInput.split(",");
       for (int index = 0; index < splittedName.length; index++) {
           if (splittedName.length < 1 || splittedName.length > 5) {
               throw new IllegalArgumentException("[ERROR] 자동차 이름은 1자 이상 5자 이하만 가능합니다.");
           }
       }
       return Arrays.asList(splittedName);
   }
   ```
   
  ---

- [ ]  메서드가 한 가지 기능을 하는지 확인하는 기준을 세운다

  여러 메서드에서 중복되는 코드가 있다면 이를 별도 메서드로 분리하는 것을 고려한다. 메서드의 길이가 길어지면 여러 기능을 포함하고 있을 가능성이 커지므로, 15라인이 넘지 않도록 구현하면 의식적으로 메서드를 분리하는 연습을 할 수 있다.

- [ ]  테스트를 작성하는 이유에 대해 본인의 경험을 토대로 정리해본다

  테스트를 작성하면 기능의 정확성을 점검함을 넘어 코드의 즉각적인 피드백을 받을 수 있다. 테스트 작성 과정을 통해 구현한 기능의 문제를 빠르게 발견할 수 있을 뿐만 아니라, 코드의 구조와 의도를 명확히 이해하는 데도 도움을 받을 수 있다. 학습 도구로도 활용할 수 있는데, 수 많은 테스트의 장점 중 본인이 가장 공감하는 작성 이유를 작성해 본다.

   - [학습테스트를 통해 JUnit 학습하기.pdf](https://techcourse-storage.s3.ap-northeast-2.amazonaws.com/9b82d8a360c548fcadd14c551dbcbe06)
- [ ]  처음부터 큰 단위의 테스트를 만들지 않는다

  테스트의 핵심 목적 중 하나는 코드에 대해 빠르고 자주 피드백을 받는 것이다. 처음부터 큰 단위의 테스트를 작성하게 되면, 작성한 코드의 문제를 발견하기까지 시간이 오래 걸린다. 따라서 문제를 작게 나누어 핵심 기능부터 작게 테스트를 만들어 가는 것이 효과적이다.

  **큰 단위의 테스트**

   - 자동차 경주 게임을 시작하여, 사용자가 이름과 진행 횟수를 입력하고, 게임을 진행한 후 결과를 확인한다.

  **작은 단위의 테스트**

   - 무작위 값이 4 이상이면 자동차가 전진한다.
   - 무작위 값이 3 이하이면 자동차가 전진하지 않는다.